#!/usr/bin/env bash

# Note: this script is usually via a keybinding, e.g. in tmux.conf like:
#
# ```
# bind-key -r i run-shell "tmux neww ~/.local/bin/llm"
# ```

set -e

# -----------------------------------------------------------------------------
#   Sanity checks
# -----------------------------------------------------------------------------
# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    sleep 2
    exit 1
fi

# -----------------------------------------------------------------------------
#    Get the current repo dir
# -----------------------------------------------------------------------------
repo_root=$(git rev-parse --show-toplevel)
current_project=$(basename "$repo_root")

# -----------------------------------------------------------------------------
#    Ask the user for a prompt
# -----------------------------------------------------------------------------
echo "> Enter a prompt for Copilot:"
echo ""
read -r task_description

if [[ -z "$task_description" ]]; then
    echo "Error: Prompt cannot be empty"
    sleep 2
    exit 1
fi

# -----------------------------------------------------------------------------
#    Ask the user for a branch name
# -----------------------------------------------------------------------------
if [[ -n "$1" ]]; then
    branch_name="$1"
else
    echo ""
    echo "> Enter a branch name (or leave blank to auto-generate):"
    echo ""
    read -r branch_name
    # Trim whitespace from branch name
    branch_name=$(echo "$branch_name" | xargs)
fi


# -----------------------------------------------------------------------------
#    Return the user to the original window
# -----------------------------------------------------------------------------
# Now we've prompted for everything we need, drop the user back into the
# original window so we don't disrupt the flow
if [[ -n "$TMUX" ]]; then
    tmux last-window
fi

# -----------------------------------------------------------------------------
#    Generate a branch name if none supplied
# -----------------------------------------------------------------------------
if [[ -z "$branch_name" ]]; then
    branch_name=$(
        copilot --prompt \
            "generate a concise but descriptive git branch name (just the name, no command) for the following task.
            Wrap your answer in double parantheses like {{some-new-branch-name}}. *Do* use kebab-case; *don't* use quotes.

            > $task_description" |
            grep -o '{{[^}]*}}' |
                sed 's/[{}]//g' |
                sed 's/[^a-z0-9-]/-/g'
            )

        # Simple fallback: create a branch name from the first few words of the
        # task description
        if [[ -z "$branch_name" ]]; then
            branch_name=$(
                echo "$task_description" |
                    tr '[:upper:]' '[:lower:]' |
                    tr -cs '[:alnum:]' '-' |
                    cut -c1-50 |
                    sed 's/-$//'
                )
        fi
fi

branch_name_full=copilot/$branch_name

# -----------------------------------------------------------------------------
#    Create the branch
# -----------------------------------------------------------------------------
git branch "$branch_name_full" 2>/dev/null || {
    exit 1
}

echo ""

# -----------------------------------------------------------------------------
#    Create a worktree for the agent to apply changes to
# -----------------------------------------------------------------------------
parent_dir=$(dirname "$repo_root")
worktree_name="${current_project}-${branch_name}"
worktree_path="${parent_dir}/${worktree_name}"

# Create git worktree
if ! git worktree add "$worktree_path" "$branch_name_full"; then
    # If we couldn't create the worktree, delete the new branch
    git branch -d "$branch_name_full" 2>/dev/null
    exit 1
fi

echo ""

# -----------------------------------------------------------------------------
#    Fill out the prompt a bit
# -----------------------------------------------------------------------------
task_description="$task_description

Make sure you commit all your changes using conventional commit messages. Don't push the branch."

# Escape the task description for safe shell usage
escaped_task=$(printf '%q' "$task_description")

# -----------------------------------------------------------------------------
#    Enter the worktree and start the agent
# -----------------------------------------------------------------------------
cd "$worktree_path"

# We add the prompt and reasoning to a markdown file. This will appear in the
# diff when the user reviews the changes, and also in the commit history.
quoted_task="> ${task_description//$'\n'/$'\n'> }"

echo "## Prompt"           | tee -a _copilot_reasoning.md
echo ""                    | tee -a _copilot_reasoning.md
echo "$quoted_task"        | tee -a _copilot_reasoning.md
echo ""                    | tee -a _copilot_reasoning.md
echo "## Result"           | tee -a _copilot_reasoning.md
echo ""                    | tee -a _copilot_reasoning.md
copilot --allow-all-tools --prompt "$escaped_task" | tee -a _copilot_reasoning.md

git add _copilot_reasoning.md
git commit -m 'docs: add copilot reasoning'

git add .
git commit -m 'chore: add any changes copilot forgot to commit' || true

# -----------------------------------------------------------------------------
#    Delete the worktree and finish
# -----------------------------------------------------------------------------
# Finally, delete the worktree. IMO removing worktrees manually is always a
# pain, so it's best to remove it automatically. From here the user can look at
# differences from the branch directly, or even create another worktree if they
# want to.
cd "$repo_root"
git worktree remove "$worktree_path"
