#!/usr/bin/env bash

# Note: this file is called via a keybinding in tmux.conf, e.g:
#   bind-key -r i run-shell "tmux neww ~/.local/bin/llm"

set -e

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    sleep 2
    exit 1
fi

# Get the current project name and repository root
repo_root=$(git rev-parse --show-toplevel)
current_project=$(basename "$repo_root")

# Read the task description from the user
echo "> Enter a prompt for Copilot:"
echo ""
read -r task_description

if [[ -z "$task_description" ]]; then
    echo "Error: Prompt cannot be empty"
    sleep 2
    exit 1
fi

if [[ -n "$1" ]]; then
    branch_name="$1"
else
    echo ""
    echo "> Enter a branch name (or leave blank to auto-generate):"
    echo ""
    read -r branch_name
    # Trim whitespace from branch name
    branch_name=$(echo "$branch_name" | xargs)
fi


# Now we've prompted for everything we need, drop the user back into the
# original window so we don't disrupt the flow
if [[ -n "$TMUX" ]]; then
    tmux last-window
else
    tmux detach
fi

# Determine branch name
if [[ -z "$branch_name" ]]; then
    # Use gh copilot to suggest a branch name based on the task description
    branch_name=$(
        copilot --prompt \
            "generate a concise but descriptive git branch name (just the name, no command) for the following task.
            Wrap your answer in double parantheses like {{some-new-branch-name}}. *Do* use kebab-case; *don't* use quotes.

            > $task_description" |
            grep -o '{{[^}]*}}' |
                sed 's/[{}]//g' |
                sed 's/[^a-z0-9-]/-/g'
            )

        # Simple fallback: create a branch name from the first few words of the task description
        if [[ -z "$branch_name" ]]; then
            branch_name=$(
                echo "$task_description" |
                    tr '[:upper:]' '[:lower:]' |
                    tr -cs '[:alnum:]' '-' |
                    cut -c1-50 |
                    sed 's/-$//'
                )
        fi
fi

branch_name_full=copilot/$branch_name

# Create the branch in the current repository
git branch "$branch_name_full" 2>/dev/null || {
    exit 1
}

# Determine parent directory and worktree path
parent_dir=$(dirname "$repo_root")
worktree_name="${current_project}-${branch_name}"
worktree_path="${parent_dir}/${worktree_name}"

# Create git worktree
if ! git worktree add "$worktree_path" "$branch_name_full"; then
    # If we couldn't create the worktree, delete the new branch
    git branch -d "$branch_name_full" 2>/dev/null
    exit 1
fi

# Create tmux session name, replacing dots with underscores, similar to tmux-sessionizer
session_name=$(echo "$worktree_name" | tr . _)

task_description="$task_description

Make sure you commit all your changes using conventional commit messages. Don't push the branch."

# Escape the task description for safe shell usage
escaped_task=$(printf '%q' "$task_description")

# Create new tmux session and start copilot with the prompt
# Run copilot directly as the initial command in the session
tmux new-session -d -s "$session_name" -c "$worktree_path" \
    "copilot --allow-all-tools --prompt $escaped_task | tee _copilot_reasoning.txt;
    git add _copilot_reasoning.txt;
    git commit -m 'docs: add copilot reasoning';
    git add .
    git commit -m 'chore: add any changes copilot forgot to commit'
    git worktree remove $worktree_path;"

