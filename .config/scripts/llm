#!/usr/bin/env bash

# Note: this file is called via a keybinding in tmux.conf, e.g:
#   bind-key -r i run-shell "tmux neww ~/.local/bin/llm"

set -e

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    sleep 2
    exit 1
fi

# Get the current project name and repository root
repo_root=$(git rev-parse --show-toplevel)
current_project=$(basename "$repo_root")

# Read the task description from the user
echo "Enter a prompt for Copilot:"
read -r task_description

if [[ -z "$task_description" ]]; then
    echo "Error: Prompt cannot be empty"
    sleep 2
    exit 1
fi

# If the user supplied an arg, use it as the branch name
branch_arg="$1"

# Return to original session/window
if [[ -n "$TMUX" ]]; then
    tmux last-window
else
    tmux detach
fi

# Determine branch name
if [[ -n "$branch_arg" ]]; then
    branch_name_short="$branch_arg"
else
    # Use gh copilot to suggest a branch name based on the task description
    branch_name_short=$(
        copilot --prompt \
            "generate a concise but descriptive git branch name (just the name, no command) for the following task.
            Wrap your answer in double parantheses like {{some-new-branch-name}}. *Do* use kebab-case; *don't* use quotes.

        > $task_description" |
            # extract the branch name from the output
        grep -o '{{[^}]*}}' |
            sed 's/[{}]//g' |
            sed 's/[^a-z0-9-]/-/g'
        )

        echo "finished copilot call"
        echo "Generated branch name from copilot: $branch_name_short"

        # Fallback if generation fails
        if [[ -z "$branch_name_short" ]]; then
            # Simple fallback: create branch name from first few words of task
            branch_name_short=$(
                echo "$task_description" |
                    tr '[:upper:]' '[:lower:]' |
                    tr -cs '[:alnum:]' '-' |
                    cut -c1-50 |
                    sed 's/-$//'
                )
        fi
fi

branch_name=copilot/$branch_name_short

# Create the branch in the current repository
git branch "$branch_name" 2>/dev/null || {
    exit 1
}

# Determine parent directory and worktree path
parent_dir=$(dirname "$repo_root")
worktree_name="${current_project}-${branch_name_short}"
worktree_path="${parent_dir}/${worktree_name}"

# Create git worktree
if ! git worktree add "$worktree_path" "$branch_name"; then
    git branch -d "$branch_name" 2>/dev/null  # Clean up the branch
    exit 1
fi

# Create tmux session name (replace dots with underscores, similar to tmux-sessionizer)
session_name=$(echo "$worktree_name" | tr . _)

task_description="$task_description

Make sure you commit all your changes using conventional commit messages. Don't push the branch."

# Properly escape the task description for safe shell usage
escaped_task=$(printf '%q' "$task_description")

# Create new tmux session and start copilot with the prompt
# Run copilot directly as the initial command in the session
tmux new-session -d -s "$session_name" -c "$worktree_path" \
    "copilot --allow-all-tools --prompt $escaped_task | tee _copilot_reasoning.txt;
    git add _copilot_reasoning.txt;
    git commit -m 'docs: add copilot reasoning';
    git add .
    git commit -m 'chore: add any changes copilot forgot to commit'
    git worktree remove $worktree_path;"

