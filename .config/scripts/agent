#!/usr/bin/env bash

# Note: this script is usually via a keybinding, e.g. in tmux.conf like:
#
# ```
# bind-key -r i run-shell "tmux neww ~/.local/bin/agent"
# ```

# TODO
# - [ ] Add the ability to specify the cli tool to use. We should let the user
#       pass additional args to the tool
# - [ ] Add a debug mode, runnable using `-d` or `--debug`. In debug mode we
#       should *not* use an AI. instead we should simulate it by just creating
#       a dummy file `test.txt` with some text in it.
# - [ ] Implement logging. Logs shoudn't be sent to stdout. The log file should
#       be configurable using an env var.
# - [ ] Add a flag --auto-name (alias -a) to skip the prompt for branch name
# - [ ] If the branch selected by the user already exists, open it in a new
#       worktree and continue adding new commits.
# - [ ] Add more robust cleanup. E.g. if the agent (or something else) fails
#       after we've created a branch/worktree, we should clean up afterwards.
# - [ ] Document usage, e.g. using -h/--help

# Exist on error
set -e

# -----------------------------------------------------------------------------
#   Sanity checks
# -----------------------------------------------------------------------------
if ! command -v git &>/dev/null; then
    echo "Error: Git is not installed."
    sleep 2
    exit 1
fi

if ! command -v copilot &>/dev/null; then
    echo "Error: The copilot CLI is not installed."
    sleep 2
    exit 1
fi

if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    sleep 2
    exit 1
fi

# -----------------------------------------------------------------------------
#    Check for uncommitted changes
# -----------------------------------------------------------------------------
if ! git diff-index --quiet HEAD --; then
    echo "> WARNING: You have uncommitted changes:"
    git status --short
    echo "> Do you wish to continue? Copilot will only work on committed files. (y/n)"
    read -r response
    if [[ "$response" != "y" && "$response" != "Y" ]]; then
        echo "Aborting..."
        sleep 1
        exit 1y
    fi
fi

# -----------------------------------------------------------------------------
#    Get the current repo dir
# -----------------------------------------------------------------------------
repo_root=$(git rev-parse --show-toplevel)
current_project=$(basename "$repo_root")

# -----------------------------------------------------------------------------
#    Ask the user for a prompt
# -----------------------------------------------------------------------------
echo "> Enter a prompt for Copilot:"
echo ""
read -r task_description

if [[ -z "$task_description" ]]; then
    echo "Error: Prompt cannot be empty"
    sleep 2
    exit 1
fi

# -----------------------------------------------------------------------------
#    Ask the user for a branch name
# -----------------------------------------------------------------------------
if [[ -n "$1" ]]; then
    branch_name="$1"
else
    echo ""
    echo "> Enter a branch name (or leave blank to auto-generate):"
    echo ""
    read -r branch_name
    # Trim whitespace from branch name
    branch_name=$(echo "$branch_name" | xargs)
fi


# -----------------------------------------------------------------------------
#    Return the user to the original window
# -----------------------------------------------------------------------------
# Now we've prompted for everything we need, drop the user back into the
# original window so we don't disrupt the flow
if [[ -n "$TMUX" ]]; then
    tmux_window=$(tmux display-message -p '#I')
    tmux last-window
fi

# -----------------------------------------------------------------------------
#    Generate a branch name if none supplied
# -----------------------------------------------------------------------------
if [[ -z "$branch_name" ]]; then
    echo "Generating branch name..."
    echo ""

    branch_name=$(
        copilot --prompt \
            "generate a concise but descriptive git branch name (just the name, no command) for the following task.
            Wrap your answer in double parantheses like {{some-new-branch-name}}. *Do* use kebab-case; *don't* use quotes.

            > $task_description" |
            grep -o '{{[^}]*}}' |
                sed 's/[{}]//g' |
                sed 's/[^a-z0-9-]/-/g'
            )

        # Simple fallback: create a branch name from the first few words of the
        # task description
        if [[ -z "$branch_name" ]]; then
            branch_name=$(
                echo "$task_description" |
                    tr '[:upper:]' '[:lower:]' |
                    tr -cs '[:alnum:]' '-' |
                    cut -c1-50 |
                    sed 's/-$//'
                )
        fi
fi

if [[ -n "$tmux_window" ]]; then
    # Not really necessary, but nice for the user to see what's going on
    tmux rename-window -t "$tmux_window" "$branch_name"
fi

branch_name_full=copilot/$branch_name

# -----------------------------------------------------------------------------
#    Create the branch
# -----------------------------------------------------------------------------
git branch "$branch_name_full" 2>/dev/null || {
    exit 1
}

# -----------------------------------------------------------------------------
#    Create a worktree for the agent to apply changes to
# -----------------------------------------------------------------------------
parent_dir=$(dirname "$repo_root")
worktree_name="${current_project}-${branch_name}"
worktree_path="${parent_dir}/${worktree_name}"

# Create git worktree
if ! git worktree add "$worktree_path" "$branch_name_full"; then
    # If we couldn't create the worktree, delete the new branch
    git branch -d "$branch_name_full" 2>/dev/null
    exit 1
fi

echo ""

# -----------------------------------------------------------------------------
#    Fill out the prompt a bit
# -----------------------------------------------------------------------------
task_description="$task_description

As you work, summarise your reasoning in a human-readable file, _COPILOT_SUMMARY.md.

IMPORTANT RULES:
*   Do not modify files outside of this worktree.
*   Do not modify the global state, e.g. by installing new software. Only
    modify files in the current worktree.
*   Do not modify .gitignore or _AGENT_CLI_OUTPUT.md.
*   Write clear, concise commit messages using conventional commit format.
*   Don't push your changes to the remote.
*   Don't switch to another branch. If you need to see anything from another
    branch, use git show or git diff.
"

# Escape the task description for safe shell usage
escaped_task=$(printf '%q' "$task_description")

# -----------------------------------------------------------------------------
#    Enter the worktree and start the agent
# -----------------------------------------------------------------------------
cd "$worktree_path"

# We add the prompt and reasoning to a markdown file. This will appear in the
# diff when the user reviews the changes, and also in the commit history.
quoted_task="> ${task_description//$'\n'/$'\n'> }"

echo "## Prompt"    | tee -a _AGENT_CLI_OUTPUT.md
echo ""             | tee -a _AGENT_CLI_OUTPUT.md
echo "$quoted_task" | tee -a _AGENT_CLI_OUTPUT.md
echo ""             | tee -a _AGENT_CLI_OUTPUT.md
echo "## Result"    | tee -a _AGENT_CLI_OUTPUT.md
echo ""             | tee -a _AGENT_CLI_OUTPUT.md
copilot --allow-all-tools --prompt "$escaped_task" | tee -a _AGENT_CLI_OUTPUT.md

git add _AGENT_CLI_OUTPUT.md
git commit -m 'docs: add copilot reasoning'

git add .
git commit -m 'chore: add any changes copilot forgot to commit' || true

# -----------------------------------------------------------------------------
#    Delete the worktree and finish
# -----------------------------------------------------------------------------
# Finally, delete the worktree. IMO removing worktrees manually is always a
# pain, so it's best to remove it automatically. From here the user can look at
# differences from the branch directly, or even create another worktree if they
# want to.
cd "$repo_root"
git worktree remove "$worktree_path"
